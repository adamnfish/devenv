package com.gu.devenv

import com.gu.devenv.modules.Modules.builtInModules
import scala.util.{Failure, Success}
import java.nio.file.Paths
import fansi.{Bold, Color}

/** Natively compiled tool that wraps the Scala logic in a CLI program.
  */
object Main {
  def main(args: Array[String]): Unit =
    args.headOption match {
      case Some("init")     => init()
      case Some("generate") => generate()
      case Some("check")    => check()
      case Some("help" | "--help" | "-h") =>
        printUsage()
      case Some("version" | "--version" | "-v") =>
        printVersion()
      case Some(unknown) =>
        System.err.println(Color.Red(s"Unknown command: $unknown"))
        printUsage()
        sys.exit(1)
      case None =>
        System.err.println(Color.Red("No command provided."))
        printUsage()
        sys.exit(1)
    }

  /** Sets up a .devcontainer directory with nested subdirectories.
    *
    * Uses the project's devenv configuration file to generate:
    *   - .devcontainer/user/ (for user-specific devcontainer with merged preferences)
    *   - .devcontainer/shared/ (for project-specific devcontainer that can be checked in)
    *   - .devcontainer/.gitignore (to exclude user directory)
    *   - .devcontainer/devenv.yaml (project-specific configuration file)
    *
    * The devcontainer.json files can be generated by running the generate command after populating
    * the project's `devenv.yaml` settings file.
    */
  def init(): Unit = {
    val devcontainerDir = Paths.get(".devcontainer")
    // these could be loaded dynamically in the future
    val modules = builtInModules

    Devenv.init(devcontainerDir, modules) match {
      case Success(result) =>
        println(Output.initResultMessage(result))
      case Failure(exception) =>
        System.err.println(s"Initialization failed: ${exception.getMessage}")
        exception.printStackTrace()
        sys.exit(1)
    }
  }

  /** Generates two devcontainer files for the current project, using the provided devenv
    * configuration.
    *
    * A user-specific file that includes properties merged from the users' own system-wide devenv
    * settings, and a generic user-agnostic devcontainer file that can be checked into the repo and
    * used for remote cloud devcontainers.
    */
  def generate(): Unit = {
    val devcontainerDir = Paths.get(".devcontainer")
    val userConfigPath =
      Paths.get(System.getProperty("user.home"), ".config", "devenv")
    // these could be loaded dynamically in the future
    val modules = builtInModules

    Devenv.generate(devcontainerDir, userConfigPath, modules) match {
      case Success(result) =>
        println(Output.generateResultMessage(result))
      case Failure(exception) =>
        System.err.println(s"Generation failed: ${exception.getMessage}")
        exception.printStackTrace()
        sys.exit(1)
    }
  }

  /** Checks whether the saved devcontainer.json files match what would be generated from the
    * current configuration.
    *
    * Validates that both user and shared devcontainer files are up-to-date with the current
    * devenv.yaml configuration. Useful for CI/CD to ensure configs are synchronized.
    */
  def check(): Unit = {
    val devcontainerDir = Paths.get(".devcontainer")
    val userConfigPath =
      Paths.get(System.getProperty("user.home"), ".config", "devenv")
    // these could be loaded dynamically in the future
    val modules = builtInModules

    Devenv.check(devcontainerDir, userConfigPath, modules) match {
      case Success(result) =>
        println(Output.checkResultMessage(result))
        result match {
          case CheckResult.Match(_, _) =>
            sys.exit(0)
          case CheckResult.Mismatch(_, _, _, _) =>
            sys.exit(1)
          case CheckResult.NotInitialized =>
            sys.exit(1)
        }
      case Failure(exception) =>
        System.err.println(s"Check failed: ${exception.getMessage}")
        exception.printStackTrace()
        sys.exit(1)
    }
  }

  private def printUsage(): Unit = {
    val header = Bold.On("Usage:") ++ " devenv " ++ Color.Cyan("<command>")
    // devenv commands
    val commandsTitle = Bold.On("Commands:")
    val initCmd       = Bold.On(Color.Cyan("init"))
    val generateCmd   = Bold.On(Color.Cyan("generate"))
    val checkCmd      = Bold.On(Color.Cyan("check"))
    val versionCmd    = Bold.On(Color.Cyan("version"))
    // version information
    val versionTitle   = Bold.On("Version:")
    val releaseLineStr = s"  release   ${Version.release}"
    val archLineStr    = Version.architecture.map(a => s"  arch      $a")
    val branchLineStr  = Version.branch.map(b => s"  branch    $b")
    val devModeNoteStr =
      if (Version.architecture.isEmpty && Version.branch.isEmpty) {
        Some("  (running in development mode)")
      } else {
        None
      }
    val versionInfoString =
      List(Some(releaseLineStr), archLineStr, branchLineStr, devModeNoteStr).flatten
        .mkString("\n")

    println(
      s"""$header
         |
         |Generates user-specific and shared devcontainer.json files from
         |devenv.yaml configuration files.
         |
         |$commandsTitle
         |  $initCmd      Initialize .devcontainer directory structure
         |  $generateCmd  Generate devcontainer.json files from .devenv config
         |  $checkCmd     Ensure devcontainer.json files match current config
         |  $versionCmd   Show devenv's version
         |
         |$versionTitle
         |$versionInfoString
         |""".stripMargin
    )
  }

  private def printVersion(): Unit = {
    // these properties are set at build time via environment variables
    // release defaults to "dev" for local development builds
    val releaseStr = Bold.On(Version.release).toString
    // architecture and branch have no fallbacks and will be empty when running locally
    val architectureStr = Version.architecture.fold("")(arch => s" ($arch)")
    val branchStr       = Version.branch.fold("")(branch => s" [$branch]")

    println(s"$releaseStr$architectureStr$branchStr")
  }
}
